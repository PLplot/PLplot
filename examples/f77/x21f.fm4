c      $Id$
c      Grid data demo.
c
c      Copyright (C) 2004  Joao Cardoso
c      Copyright (C) 2008  Andrew Ross
c
c      This file is part of PLplot.
c
c      PLplot is free software; you can redistribute it and/or modify
c      it under the terms of the GNU General Library Public License as
c      published by the Free Software Foundation; either version 2 of the
c      License, or (at your option) any later version.
c
c      PLplot is distributed in the hope that it will be useful,
c      but WITHOUT ANY WARRANTY; without even the implied warranty of
c      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c      GNU Library General Public License for more details.
c
c      You should have received a copy of the GNU Library General Public
c      License along with PLplot; if not, write to the Free Software
c      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

      include 'plf77demos.inc'

      implicit none

      real*8 PI
      parameter (PI = 3.1415926535897932384d0)

      integer PL_PARSE_FULL
      parameter(PL_PARSE_FULL = 1)
      
      integer GRID_CSA, GRID_DTLI, GRID_NNI, GRID_NNIDW, GRID_NNLI, 
     &     GRID_NNAIDW
      parameter (GRID_CSA = 1)
      parameter (GRID_DTLI = 2)
      parameter (GRID_NNI = 3)
      parameter (GRID_NNIDW = 4)
      parameter (GRID_NNLI = 5)
      parameter (GRID_NNAIDW = 6)

      integer DRAW_LINEXY, MAG_COLOR, BASE_CONT
      parameter(DRAW_LINEXY = 3)
      parameter(MAG_COLOR = 4)
      parameter(BASE_CONT = 8)
       
      external plrandd
      real*8 plrandd

c     The function myisnan is defined in plf77demos.h
      external myisnan
      logical myisnan

      integer pts, xp, yp, nl, knn_order, randn, rosen
      real*8 threshold, wmin
      parameter (pts = 500)
      parameter (xp = 25)
      parameter (yp = 20)
      parameter (nl = 16)
      parameter (knn_order = 20)
      parameter (threshold = 1.001d0)
      parameter (wmin = -1d3)
      parameter (randn = 0)
      parameter (rosen = 0)

      real*8 xmin, xmax, ymin, ymax
      
      real*8 x(pts), y(pts), z(pts), clev(nl)
      real*8 xg(xp), yg(yp), zg(xp,yp)
      real*8 zmin, zmax, lzmin, lzmax
      integer i, j, k
      integer alg;
      character*80 title(6)
      data title /'Cubic Spline Approximation',
     &            'Delaunay Linear Interpolation',
     &		  'Natural Neighbors Interpolation',
     &		  'KNN Inv. Distance Weighted',
     &		  '3NN Linear Interpolation',
     &            '4NN Around Inv. Dist. Weighted'/

      real*8 opt(6)
      data opt /0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0/

      real*8 xt, yt

      real*8 r
      integer ii, jj
      real*8 dist, d

      character*1 defined

      xmin = -0.2d0
      ymin = -0.2d0
      xmax = 0.6d0
      ymax = 0.6d0

c      call plMergeOpts(options, "x21c options", NULL);
      call plparseopts(PL_PARSE_FULL);

      opt(3) = wmin;
      opt(4) = dble(knn_order);
      opt(5) = threshold;

c Initialize plplot

      call plinit

      call plseed(5489)

      do i=1,pts
         xt = (xmax-xmin)*plrandd()
         yt = (ymax-ymin)*plrandd()
         if (randn.eq.0) then
            x(i) = xt + xmin
            y(i) = yt + ymin
         else
            x(i) = sqrt(-2.d0*log(xt)) * cos(2.d0*PI*yt) + xmin
            y(i) = sqrt(-2.d0*log(xt)) * sin(2.d0*PI*yt) + ymin
         endif
         if (rosen.eq.0) then
            r = sqrt(x(i)*x(i) + y(i)*y(i))
            z(i) = exp(-r*r)*cos(2.d0*PI*r)
         else
            z(i) = log((1.d0-x(i))**2 + 100.d0*(y(i)-x(i)**2)**2)
         endif
      enddo
      
      zmin = z(1)
      zmax = z(1)
      do i=2,pts
         zmax = max(zmax,z(i))
         zmin = min(zmin,z(i))
      enddo

      do i=1,xp
         xg(i) = xmin + (xmax-xmin)*(i-1.d0)/(xp-1.d0)
      enddo
      do i=1,yp
         yg(i) = ymin + (ymax-ymin)*(i-1.d0)/(yp-1.d0)
      enddo
      
      call plcol0(1)
      call plenv(xmin, xmax, ymin, ymax, 2, 0)
      call plcol0(15)
      call pllab("X", "Y", "The original data sampling")
      call plcol0(2)
      call plpoin(pts, x, y, 5)
      call pladv(0)

      call plssub(3,2)

      do k=1,2
         call pladv(0);
         do alg=1,6

            call plgriddata(x, y, z, pts, xg, xp, yg, yp, zg, alg, 
     &           opt(alg),xp)

c     - CSA can generate NaNs (only interpolates? !).
c     - DTLI and NNI can generate NaNs for points outside the convex hull
c     of the data points.
c     - NNLI can generate NaNs if a sufficiently thick triangle is not found
c
c     PLplot should be NaN/Inf aware, but changing it now is quite a job...
c     so, instead of not plotting the NaN regions, a weighted average over
c     the neighbors is done.
c

            if ((alg.eq.GRID_CSA).or.(alg.eq.GRID_DTLI).or.
     &           (alg.eq.GRID_NNLI).or.(alg.eq.GRID_NNI)) then
               
               do i=1,xp
                  do j=1,yp
                     if (myisnan(zg(i,j))) then
c     average (IDW) over the 8 neighbors
                        
                        zg(i,j) = 0.d0
                        dist = 0.d0
                        
                        ii=i-1
                        do while ((ii.le.i+1).and.(ii.le.xp))
                           jj = j-1
                           do while ((jj.le.j+1).and.(jj.le.yp))
                              if ((ii.ge.1) .and. (jj.ge.1) .and.
     &                             (.not.myisnan(zg(ii,jj))) ) then
                                 if (abs(ii-i) + abs(jj-j) .eq. 1) then
                                    d = 1.d0
                                 else
                                    d = 1.4142d0
                                 endif
                                 zg(i,j) = zg(i,j) + zg(ii,jj)/(d*d)
                                 dist = dist + d
                              endif
                              jj = jj+1
                           enddo
                           ii = ii+1
                        enddo
                        if (dist.ne.0.d0) then
                           zg(i,j) = zg(i,j) / dist
                        else
                           zg(i,j) = zmin
                        endif
                     endif
                  enddo
               enddo
            endif
            
            call a2mnmx(zg, xp, yp, lzmin, lzmax, xp)

            lzmin = min(lzmin, zmin)
            lzmax = max(lzmax, zmax)

            lzmin = lzmin - 0.01d0
            lzmax = lzmax + 0.01d0

            call plcol0(1)
            call pladv(alg)
            
            if (k.eq.1) then
               
               do i=1,nl
                  clev(i) = lzmin + (lzmax-lzmin)/(nl-1.d0)*(i-1.d0);
               enddo
               call plenv0(xmin, xmax, ymin, ymax, 2, 0)
               call plcol0(15)
               call pllab("X", "Y", title(alg))
               call plshades0(zg, xp, yp, defined, xmin, xmax, ymin, 
     &              ymax, clev, nl, 1, 0, 1, xp)
               call plcol0(2)
            else
               
               do i = 1,nl
                  clev(i) = lzmin + (lzmax-lzmin)/(nl-1.d0)*(i-1.d0);
               enddo
               call cmap1_init()
               call plvpor(0.d0, 1.d0, 0.d0, 0.9d0)
               call plwind(-1.1d0, 0.75d0, -0.65d0, 1.20d0)
c     
c     For the comparison to be fair, all plots should have the
c     same z values, but to get the max/min of the data generated
c     by all algorithms would imply two passes. Keep it simple.
c
c     plw3d(1., 1., 1., xmin, xmax, ymin, ymax, zmin, zmax, 30, -60);
c
               
               call plw3d(1.d0, 1.d0, 1.d0, xmin, xmax, ymin, ymax, 
     &              lzmin, lzmax, 30.d0, -40.d0)
               call plbox3("bntu", "X", 0.d0, 0,
     &              "bntu", "Y", 0.d0, 0,
     &              "bcdfntu", "Z", 0.5d0, 0)
               call plcol0(15)
               call pllab("", "", title(alg))
               call plot3dc(xg, yg, zg, xp, yp, ior(ior(DRAW_LINEXY,
     &              MAG_COLOR), BASE_CONT), clev, nl, xp)
            endif
         enddo
      enddo

      call plend
            
      end

      subroutine cmap1_init
      implicit none
      real*8 i(2), h(2), l(2), s(2), rev(2)
      
      i(1) = 0.d0
      i(2) = 1.d0

      h(1) = 240.d0
      h(2) = 0.d0
      
      l(1) = 0.6d0
      l(2) = 0.6d0

      s(1) = 0.8d0
      s(2) = 0.8d0

      rev(1) = 0
      rev(2) = 0

      call plscmap1n(256)
      call plscmap1l(0, 2, i, h, l, s, rev)
      end subroutine


c      function myisnan(x)
c      implicit none
c      
c      logical myisnan
c      real*8 x
c
c      myisnan = (x.ne.x)
c      return
c      end function


c----------------------------------------------------------------------------
c      Subroutine a2mnmx
c      Minimum and the maximum elements of a 2-d array.

      subroutine a2mnmx(f, nx, ny, fmin, fmax, xdim)
      implicit none

      integer   i, j, nx, ny, xdim
      real*8    f(xdim, ny), fmin, fmax

      fmax = f(1, 1)
      fmin = fmax
      do j = 1, ny
        do  i = 1, nx
          fmax = max(fmax, f(i, j))
          fmin = min(fmin, f(i, j))
        enddo
      enddo
      end
