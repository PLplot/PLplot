SUMMARY:

The purpose of this complete project is to provide a simple test
case for CMake D language support.

DESCRIPTION:

This project consists of a C library which defines a function
that returns the classic "hello, world" C string, a D library which
calls the C routine and changes the returned C string to a D string,
and a D executable that calls that wrapper and prints out that D
string with '\n' appended.  This complete project includes a
CMake-based build system and updated D language support from the
[cmake-d project](https://github.com/dcarp/cmake-d).  The plan is to
make those updates available to that project after the CMake fix
discussed below makes it into a CMake release.

LICENSING:

Aside from the files noted below, all files in the
test_d package may be distributed under the following (LGPL version
2 or later) terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc. 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

The full text of this license is given in the file COPYING.LIB.

The only exceptions to the above licensing terms are all the files in
cmake/Modules which are licensed under the MIT license as described in
cmake/Modules/LICENSE.

TESTING PROCEDURE:

The test_d project may be used to test the CMake D language support as follows:

(1) Both dmd and ldc language-support files set language-support CMake
variables that are only supported now by a CMake commit (git described as v3.15.2-908-g3ec986ce8e)
that has just (as of 2019-08-29) landed on the CMake master branch and which
will become part of CMake-3.16.0 once that new version of CMake is
released.  So as a first step in this test procedure, you should build
CMake from the tip of its git master branch or from CMake-3.16.0 source
code once that version of CMake is released.

N.B. Similarly, if you are using dmd, you MUST have access to a dmd
version that includes support for either the -preview=noXlinker dmd
option that landed on the dmd git master branch on 2019-08-31 as
commit d6183e9ff or Cybershadow's alternative effort to implement the
-Xcc approach instead.  The reason there are two implementations of the dmd
effort to allow users to communicate options to the underlying C
compiler is at the time of writing (2019-09-28) there is still
[debate] (https://github.com/dlang/dmd/pull/10438) about whether they
want to deal with the -L general change in semantics implemented by
the -preview=noXlinker approach (all -L options would communicate
those options to the underlying compiler rather than the previous approach
where -L communicated options with the linker invoked by that
compiler).  As a result of this discussion, CyberShawdow has begun
work on an alternative to the -preview=noXlinker approach that follows
what ldc2 does which is to implement an -Xcc option to communicate
with the underlying C compiler used for linking with -L continuing as
the flag used to communicate directly with the linker invoked by that
compiler.

PLplot needs one of these approaches or the other to deal with the
-pthread option that MUST be communicated to the underlying C
compiler, but since our D language support currently assumes -L means
communicate all -L options to the linker, and I had just started to
change that support to the -preview=noXlinker semantics, I will stick
with the CyberShadow approach for now, with the understanding that we
could also get the -preview=noXlinker new -L semantics to work with
some fairly trivial changes in our D language support for dmd, if the
dmd developers decide (finally) that is the approach they want to
take.

Therefore, I built and installed the -preview=noXlinker version of dmd
first following the instructions in
<https://wiki.dlang.org/Building_under_Posix> for POSIX platforms like
Linux, Mac OS X, etc.  Or those on Windows could follow the instructions in
<https://wiki.dlang.org/Building_under_Windows>.
I then copied that
hard-coded install location /home/software/dmd/install to /home/software/dmd/install_noXlinker so
I can potentially get access to it later.  And then I rebuilt and reinstalled
dmd with the CyberShadow preliminary pull request concerning -Xcc support using
the following steps:

# Change to the preexisting dmd repository whose single remote
# previously accessed just the master branch of dmd.
cd ~/dmd/dmd
# Add the CyberShadow remote, fetch it, and checkout the branch of his work where he is working on
# implementing a -Xcc option similar to that already available for ldc2.

git remote add CyberShadow https://github.com/CyberShadow/dmd
git fetch --all
git checkout pull-20190926-222551

# Then I did what I normally do to rebuild and reinstall dmd
# (following the directions at
# <https://wiki.dlang.org/Building_under_Posix>) using this
# -Xcc-capable version.  Since this rebuild and reinstall was done
# after the other one, the installed version is available in the
# hard-coded location "/home/software/dmd/install/linux/bin64/dmd
# which is accessed via setting the PATH and DC environment variables
# below.

(2) Check documentation of comprehensive test of D language support on
your platform as follows:

scripts/comprehensive_test.sh --help

This script is similar in concept but quite different (note its
different location) than the corresponding script in
../../scripts/comprehensive_test.sh which comprehensively tests all of
PLplot so do not confuse the two.

(3) Actually do comprehensive test of D language support as follows:

<set environment> scripts/comprehensive_test.sh

where <set environment> sets up the cmake binary built from cmake
source code git commit v3.15.2-908-g3ec986ce8e and one of the gdc,
ldc, or dmd compilers.

For example, on my Debian Buster system <set environment> was one of the three following possibilities:

# I. dmd (and the same version of phobos) built by myself since Debian
# Buster does not supply a system version.

# N.B. Currently I am testing the CyberShadow PR to provide the -Xcc option for dmd.
# See previous dmd comments about this version.  To gain
# access to that work I used the PATH setting below:

# N.B. This build system is a simple one that does not set up RPATH to find the particular phobos library
# required when linking D libraries and executables.  So must set LD_LIBRARY_PATH appropriately.

# We use the -v option for dmd so that we can see the actual derived
# command-line that dmd uses to communicate with the linker.

env PATH=/home/software/cmake/install-3ec986ce8e/bin:/home/software/dmd/install/linux/bin64:"$PATH" LD_LIBRARY_PATH=/home/software/dmd/install/linux/lib64  DC="dmd -v"

# II. system ldc
env PATH=/home/software/cmake/install-3ec986ce8e/bin:"$PATH" DC=ldc2

# III. system gdc
env PATH=/home/software/cmake/install-3ec986ce8e/bin:"$PATH" DC=gdc

For our two principal build configurations (shared libraries and
static libraries) this script (if executed without options) builds the
test_noninteractive target (which builds the "hello" executable and
all its prerequisites, runs that executable, and compares the output
of that executable with the expected output) in the build tree and in
the installed examples tree.

# Check for errors.  Last pipeline stanza filters out dmd -v results for function internals
#  that mention case-insensitive "error" anywhere on the D language source code for the function.
grep -i error ../../../comprehensive_test_d_disposeable/*/*/output_tree/*.out |grep -v out:function

# Check for warnings
grep -i warning ../../../comprehensive_test_d_disposeable/*/*/output_tree/*.out

# Check (Linux only) for any undefined symbol issues discovered by the script.
grep -iE 'found|symbol|undefined' ../../../comprehensive_test_d_disposeable/*/*/output_tree/*ldd.out

# Check references to -pthread flag to help evaluate whether the
# -pthread logic is working as expected.
grep 'Check if compiler accepts \-pthread' ../../../comprehensive_test_d_disposeable/*/*/output_tree/*.out |less
grep '\-pthread' ../../../comprehensive_test_d_disposeable/*/*/output_tree/*.out | grep -v 'Check if compiler accepts \-pthread' | less

Send me (Alan W. Irwin <airwin@users.sourceforge.net> the report
tarball (of information that is collected by that script at
../../../comprehensive_test_d_disposeable/comprehensive_test.tar.gz)
for further analysis of any issues you discover.

(4, optional) Debug result:

If (3) shows any errors than you can optionally debug the result as
follows:

<set environment> scripts/comprehensive_test.sh --do_trace yes

This produces voluminous results and buried (deeply) in those is
typically enough information to find out what is going wrong with the
CMake D language support.  These voluminous results are automatically
included in the tarball report so please send that report to me (as
well as the one created without the --do_trace yes option in step 3).

(5, optional) Test with valgrind:

Create an empty build tree, run cmake from there, create the hello
executable and test that with valgrind.

mkdir build_dir
cd build_dir
<set environment> cmake -DBUILD_TEST=ON <path to top-level of test_d source tree> >& cmake.out
make hello >& hello.out
valgrind src_executable/hello >& valgrind.out

Look through the generated *.out files for any error conditions.

In sum, this project provides a simple demonstration of how to use the
CMake D language support with D wrapper libraries for C libraries that
are either static or shared, and for any of the three principal D
compilers (dmd, ldc, and/or gdc).  At the same time, this project
tests the quality of CMake D support for various user's platforms for
any of those three compilers.  If any user is having trouble with
CMake D language support for any of those compilers, they should run
at least step (3) and step (4) above.
