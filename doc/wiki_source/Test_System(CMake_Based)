<!---
N.B.  The definitive Markdown source of this file is located in the
doc/wiki_source subdirectory of the PLplot source tree.  So only use
the ctrl-v and delete capabilities of the GUI file editor at
SourceForge to make changes to the SourceForge version of this file,
where ctrl-v is used to complete a cut and paste from the definitive
version of this file in the PLplot source tree that is being edited
with your favorite file editor, and delete used to remove extraneous
unmodified text whose changed form has been copied with the cut and
paste.
-->

### The CMake-based test system

This test system is one of three implemented for PLplot with the other two being the [CTest-based test system](Test_System(CTest_Based) "wikilink") and the [legacy test system](Test_System(Legacy) "wikilink").  Other wiki links relevant to PLplot testing are [a general discussion of PLplot testing](Testing_PLplot "wikilink") and [a summary of our comprehensive testing reports](Testing_Reports "wikilink").

The following two sets of commands are typical ways to use this test system for the CMake "Unix Makefiles" generator in the core build tree and in the build tree for the installed examples.

~~~
# Example of using the CMake-based test system for the core build tree.
# 1. Configure a PLplot core build with CMake as normal in an initially
# empty build tree.
CORE_BUILD_DIR=$HOME/plplot_core_build_dir
rm -rf $CORE_BUILD_DIR
mkdir $CORE_BUILD_DIR
cd $CORE_BUILD_DIR
# N.B. the CMake-based test system does not work in the core build tree unless -DBUILD_TEST=ON.
cmake -DCMAKE_INSTALL_PREFIX=<install prefix> -DBUILD_TEST=ON <other cmake options> <top-level directory of the PLplot source tree> >& cmake.out
# 2. Build a test target.
make VERBOSE=1 -j<jobs> <some test target> >& <some_test_target>.out
~~~

~~~
# Example of using the CMake-based test system for the installed examples build tree.
# After step and possibly step 2 above,  do the following:
# 3. Install PLplot
make VERBOSE=1 -j<jobs> install >& install.out
# 4. Configure the CMake-based build system for the installed examples in an initially empty build tree.
# N.B. note that no CMake options are allowed for this step.
INSTALLED_BUILD_DIR=$HOME/plplot_installed_build_dir
rm -rf $INSTALLED_BUILD_DIR
mkdir $INSTALLED_BUILD_DIR
cd $INSTALLED_BUILD_DIR
# N.B. note there are no parameters allowed for this particular cmake command
cmake <install_prefix>/share/plplot<plplot_version>/examples ctest.out
# 5. Build a test target.
make VERBOSE=1 -j<jobs> <some test target> >& <some_test_target>.out
~~~

The tester should be able to infer from these "Unix Makefiles" examples how to use the CMake-based test system for any other CMake generator as well.

In the above commands, $HOME is an environment variable pointing to your home directory; &lt;install_prefix&gt; should point to an initially non-existent disk directory that will become the top-level directory of the install tree; &lt;other cmake options&gt; can be any additional cmake options you want to specify to control the PLplot configuration; &lt;top-level directory of the PLplot source tree&gt; is self-explanatory; &lt;jobs&gt; is the maximum number of parallel jobs that will be executed by the make command (for most efficient results this integer should match the number of hardware threads for your box (e.g., it should be 16 for a Ryzen 7 1700 system with 8 real cores and 16 threads); &lt;some_test_target&gt; is one of the test targets [listed here](#target_list "wikilink") such as "test_noninteractive"; and &lt;plplot_version&gt; is the PLplot version number, e.g., "5.15.0".

You should search the \*.out files generated by the above commands for obvious configuration, build, or run-time errors.  You should also look for rendering issues associated with interactive targets (in the displays they generate) and noninteractive targets (using an appropriate viewer such as the [ImageMagick](http://www.imagemagick.org/) "display" application to view the files they generate in the examples/test_examples_output_dir subdirectory of the build tree).

The building blocks of this [CMake-based test system](Test_System(CMake_Based) "wikilink") are low-level custom test targets that are configured by combined add_custom_command and add_custom_target CMake commands in the examples/CMakeLists.txt file in the PLplot source tree.  Assuming all file- and target-level dependencies are correctly implemented for these combined commands means building any low-level custom test target will automatically build the necessary prerequisites for that target.

For testing convenience higher-level custom targets such as test_diff_device, test_noninteractive, and test_interactive are configured by using the add_custom_target command to create a target that depends (via the add_dependencies CMake command) on certain low-level custom test targets which are therefore automatically built whenever the high-level target is built.

The test_diff_device target tests the noninteractive capabilities of PLplot by comparing results for a particular noninteractive plot device, ${PLPLOT_TEST_DEVICE}, for our complete set of C examples with the corresponding results from all of our other supported languages and reports any differences as a strong test of the consistency of the PLplot API from language to language.  The particular plot device used for ${PLPLOT_TEST_DEVICE} is "svg" by default since that modern device demonstrates the full noninteractive power of PLplot (e.g., UTF-8 input in essentially all human languages is rendered correctly and a native gradient capability is implemented) and that device has no extra library dependencies (so it is automatically available on all platforms).  However, other noninteractive plot devices can be chosen for the comparison by specifying the CMake option -DPLPLOT_TEST_DEVICE=&lt;test device&gt;, where &lt;test device&gt; can be any noninteractive device that is suitable for such comparisons.

The test_noninteractive target tests more extensive noninteractive capabilities for PLplot by running all the comparison tests described for the test_diff_device target as well as running all the noninteractive devices (other than ${PLPLOT_TEST_DEVICE}) for our standard C examples.  The test_interactive target tests the interactive capabilities of PLplot by running our standard set of C examples for all our interactive devices as well as many other special interactive tests (mostly written in C or C++).  In sum, the test_diff_device target tests how well changes in our C API and standard set of C examples have been propagated to our other supported language bindings and examples for a particular plot device, the test_noninteractive target does that and additionally tests every other noninteractive device for our standard set of C examples, and the test_interactive device tests all our interactive plot devices for our standard set of C examples and also runs additional interactive tests of PLplot.

When a low-level noninteractive test target is built, e.g., test_c_svgqt, all prerequisites are built (e.g., the qt target which builds the qt device driver which implements the svgqt device).  Furthermore, the named noninteractive device (in this case svgqt) is run-time tested for the C examples as the name of the test_c_svgqt target implies.  The results are a series of files written in a particular image format (SVG in the case of the svgqt device).  These plot files (which are located in the examples/test_examples_output_dir subdirectory in the build tree must be viewed with appropriate viewer to check for rendering issues.

When a low-level interactive test target is built, e.g., test_c_qtwidget, all prerequisites are built (e.g., the qt target which builds the qt device driver which implements the qtwidget interactive device). Furthermore, the named interactive device (in this case qtwidget) is run-time tested for the C examples as the name of the test_c_qtwidget target implies.  In the interest of reducing how much user effort is required to finish such low-level interactive tests, the run-time testing of such interactive devices is done with the -np (no-pause) option.  For properly implemented interactive devices this option allows the user to look at all pages of all the tested examples for rendering issues without the user interaction normally required to navigate from one page of an example to another or to exit any given example once all pages have been displayed for it.

#### <a name="target_list"></a>Target names
To obtain a sorted list of all targets for the [CMake-based test system](Test_System(CMake_Based) "wikilink") build the "help" target, select target names in those results that have the "test" prefix in the target name, exclude "test" targets which are known to not be part of this test system, and sort the results.  When those steps are implemented with the compound command,

`make help |grep '^... test' |grep -vE '^... test$|test-drv-info|dyndriver' |sort`

on a Linux platform with essentially all PLplot prerequisites installed, the following results
are obtained:

~~~
... test_ada_svg
... test_all_cairo
... test_c_bmpqt
... test_c_epscairo
... test_c_jpgqt
... test_c_ntk
... test_c_pdfcairo
... test_c_pdfqt
... test_c_pngcairo
... test_c_pngqt
... test_c_ppmqt
... test_c_ps
... test_c_psc
... test_c_pscairo
... test_c_psttf
... test_c_psttfc
... test_c_qtwidget
... test_c_svg
... test_c_svgcairo
... test_c_svgqt
... test_c_tiffqt
... test_c_tk
... test_c_wxwidgets
... test_c_xcairo
... test_c_xfig
... test_c_xwin
... test_cxx_svg
... test_d_svg
... test_diff_device
... test_extcairo
... test_fortran_svg
... test_interactive
... test_java_svg
... test_lua_svg
... test_noninteractive
... test_ocaml_svg
... test_octave_ntk
... test_octave_qtwidget
... test_octave_svg
... test_octave_tk
... test_octave_wxwidgets
... test_octave_xcairo
... test_octave_xwin
... test_plbuf
... test_plend
... test_plfortrandemolib
... test_plserver_runAllDemos
... test_plserver_standard_examples
... test_pltcl_standard_examples
... test_pyqt5_example
... test_python_svg
... test_pytkdemo
... test_qt_example
... test_tcl
... test_tcl_svg
... test_tclsh_standard_examples
... test_tk
... test_tk_01
... test_tk_02
... test_tk_03
... test_tk_04
... test_tk_plgrid
... test_wish_runAllDemos
... test_wish_standard_examples
... test_wxPLplotDemo
~~~

These target names are largely self-explanatory.  For example, the low-level test_c_svgqt and test_c_qtwidget targets run all our standard examples implemented with "C" using -dev svgqt and -dev qtwidget to thoroughly test those noninteractive and interactive devices.  Some high-level test targets such as the already-mentioned test_diff_device, test_noninteractive, and test_interactive targets as well as others such as test_all_cairo, test_all_qt, test_tcl, and test_tk also do what their name implies and are implemented by invoking other selected low-level test targets as dependencies.

#### <a name="plot_filenames"></a>Plot filenames

Here are results generated in the examples/test_examples_output_dir subdirectory of the build tree for either the test_diff_device or test_noninteractive targets for -dev svg and example 2.

~~~
x02c_svg.txt
x02cxx_svg.txt
x02d_svg.txt
x02f_svg.txt
x02j_svg.txt
x02lua_svg.txt
x02o_svg.txt
x02ocaml_svg.txt
x02p_svg.txt
x02t_svg.txt
xstandard02a_svg.txt
xtraditional02a_svg.txt

x02c01.svg
x02c02.svg
x02cxx01.svg
x02cxx02.svg
x02d01.svg
x02d02.svg
x02f01.svg
x02f02.svg
x02j01.svg
x02j02.svg
x02lua01.svg
x02lua02.svg
x02o01.svg
x02o02.svg
x02ocaml01.svg
x02ocaml02.svg
x02p01.svg
x02p02.svg
x02t01.svg
x02t02.svg
xstandard02a01.svg
xstandard02a02.svg
xtraditional02a01.svg
xtraditional02a02.svg
~~~

We have selected these results for -dev svg since that is the default device used for the difference report referred to above.  And we have selected example 2 file results since that is an example with only two pages.  The "x02c", "x02cxx", "x02d", "x02f", "x02j", "x02lua", "x02o", "x02ocaml", "x02p", "x02t", "xstandard02a", and "xtraditional02a" filename prefixes correspond to the C, C++, D, Fortran 95, Java, Lua, Octave, OCaml, Python, Tcl, and Ada (for both the standard and traditional Ada interfaces) language results.  The remaining "_svg.txt", 01.svg", and "02.svg" suffixes refer to the example 2 stdout results and plot results for first and second pages of example 2 (since the svg device is a "familied" device that must use separate files to contain the results for the two separate plot pages of example 2) for the given language and device.

You can view any of these \*.txt with any text viewer (e.g., the "less" application) and any of these \*.svg plot files results using an appropriate image viewer (e.g.,the [ImageMagick](http://www.imagemagick.org/) "display" application).  The difference test report referred to above compares non-C stdout and -dev svg plot file results in this list with the corresponding C results for example 2 (and similarly for all the other standard PLplot examples).  So assuming this report shows no differences, testers only need to view the C versions of the \*svg.txt files and C versions of the \*.svg plot files for any text or rendering issues.

For a fully loaded Linux platform, here are the additional (beyond what is generated by the test_diff_device target) text and plot file results generated by the test_noninteractive target.

~~~
x02c_bmpqt.txt
x02c_epscairo.txt
x02c_jpgqt.txt
x02c_pdfcairo.txt
x02c_pdfqt.txt
x02c_pngcairo.txt
x02c_pngqt.txt
x02c_ppmqt.txt
x02c_ps.txt
x02c_psc.txt
x02c_pscairo.txt
x02c_psttf.txt
x02c_psttfc.txt
x02c_svgcairo.txt
x02c_svgqt.txt
x02c_tiffqt.txt
x02c_xfig.txt

x02c.pdfcairo
x02c.ps
x02c.psc
x02c.pscairo
x02c.psttf
x02c.psttfc
x02c01.bmpqt
x02c01.epscairo
x02c01.jpgqt
x02c01.pdfqt
x02c01.pngcairo
x02c01.pngqt
x02c01.ppmqt
x02c01.svgcairo
x02c01.svgqt
x02c01.tiffqt
x02c01.xfig
x02c02.bmpqt
x02c02.epscairo
x02c02.jpgqt
x02c02.pdfqt
x02c02.pngcairo
x02c02.pngqt
x02c02.ppmqt
x02c02.svgcairo
x02c02.svgqt
x02c02.tiffqt
x02c02.xfig
~~~

Since different devices are involved in all cases, these text and plot files should be viewed individually for text or rendering issues (and similarly for the rest of our 33 standard examples). Note such checking is a huge job so we certainly don't expect it of our testers very often, but it is worth doing for a given platform once every year or so and especially for new or changed examples or devices that haven't been checked before.

The content of this page is available under the [GNU Free Documentation License 1.2](http://www.gnu.org/copyleft/fdl.html).
